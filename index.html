<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher Schedule Viewer</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #2c3e50;
            text-align: center;
        }
        h2 {
            margin-top: 30px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #e9ecef;
            font-weight: bold;
        }
        td.day-header {
            font-weight: bold;
            background-color: #f8f9fa;
            width: 80px; /* Fixed width for Day column */
        }
        .rehat-cell {
            background-color: #e6ffed; /* Light green for REHAT */
            color: #28a745;
            font-weight: bold;
            text-align: center;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
        }
        .controls label {
            margin-right: 10px;
            font-weight: bold;
        }
        .controls input[type="file"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .controls button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        #statusArea {
            margin-top: 15px;
            font-style: italic;
            color: #555;
            text-align: center;
        }
        .schedule-entry {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .schedule-entry li {
            padding: 2px 0;
        }
    </style>
    <!-- PDF.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script>
        // Set workerSrc for pdf.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
    </script>
</head>
<body>
    <div class="container">
        <h1>Teacher Schedule Viewer</h1>

        <div class="controls">
            <label for="jsonFileManual">Load Another JSON File:</label>
            <input type="file" id="jsonFileManual" accept=".json">
            <button onclick="loadJsonFromManualFile()">Load JSON</button>
            <br><br>
            <label for="pdfFile">Import PDF File (for new extraction):</label>
            <input type="file" id="pdfFile" accept=".pdf">
            <button onclick="processPdf()">Process PDF</button>
        </div>

        <div id="statusArea">Attempting to load default schedule...</div>
        <div id="scheduleOutput">
            <!-- Tables will be rendered here -->
        </div>
    </div>

    <script>
        const DEFAULT_JSON_PATH = 'teacher_schedules.json'; // The JSON file in your GitHub repo
        const DAYS_ORDER = ["Mo", "Tu", "We", "Th", "Fr"];
        const EXPECTED_TIME_SLOTS_KEYS = [
            "07:15-07:45", "07:45-08:15", "08:15-08:45", "08:45-09:15", "09:15-09:45",
            "09:45-10:00", "09:45-10:15", "10:00-10:30", "10:15-10:30", "10:30-11:00",
            "11:00-11:30", "11:30-12:00", "12:00-12:30", "12:30-13:00", "13:00-13:30",
            "13:30-14:00", "14:00-14:30", "14:30-15:00", "15:00-15:30"
        ];

        function setStatus(message, isError = false) {
            const statusArea = document.getElementById('statusArea');
            statusArea.textContent = message;
            statusArea.style.color = isError ? 'red' : '#555';
        }

        async function loadAndDisplayJson(filePath, sourceDescription) {
            setStatus(`Loading ${sourceDescription}...`);
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} while fetching ${filePath}`);
                }
                const jsonData = await response.json();
                displaySchedules(jsonData);
                setStatus(`${sourceDescription} loaded and displayed.`);
            } catch (e) {
                setStatus(`Error loading or parsing ${sourceDescription}: ${e.message}`, true);
                console.error(`Error with ${sourceDescription}:`, e);
                if (sourceDescription.includes("default")) {
                     document.getElementById('scheduleOutput').innerHTML = `<p>Could not load default schedule from ${DEFAULT_JSON_PATH}. You can try loading another JSON file manually or processing a PDF.</p>`;
                }
            }
        }

        function loadJsonFromManualFile() {
            const fileInput = document.getElementById('jsonFileManual');
            if (fileInput.files.length === 0) {
                setStatus("Please select a JSON file first.", true);
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const jsonData = JSON.parse(event.target.result);
                    displaySchedules(jsonData);
                    setStatus(`JSON file "${file.name}" loaded and displayed.`);
                } catch (e) {
                    setStatus(`Error parsing JSON file "${file.name}": ${e.message}`, true);
                    console.error("Error parsing JSON:", e);
                }
            };
            reader.onerror = function() {
                setStatus(`Error reading file "${file.name}": ${reader.error}`, true);
            };
            reader.readAsText(file);
        }

        function displaySchedules(allTeachersData) {
            const outputDiv = document.getElementById('scheduleOutput');
            outputDiv.innerHTML = ''; 

            if (!allTeachersData || Object.keys(allTeachersData).length === 0) {
                outputDiv.innerHTML = '<p>No schedule data to display.</p>';
                return;
            }

            const timeHeaders = [...EXPECTED_TIME_SLOTS_KEYS];

            for (const teacherName in allTeachersData) {
                const teacherSchedule = allTeachersData[teacherName];

                const teacherHeader = document.createElement('h2');
                teacherHeader.textContent = teacherName;
                outputDiv.appendChild(teacherHeader);

                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                const headerRow = document.createElement('tr');
                const dayTh = document.createElement('th');
                dayTh.textContent = 'Day';
                headerRow.appendChild(dayTh);

                timeHeaders.forEach(timeSlot => {
                    const th = document.createElement('th');
                    th.textContent = timeSlot.replace('-', ' - ');
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                DAYS_ORDER.forEach(dayKey => {
                    if (teacherSchedule[dayKey]) {
                        const dayData = teacherSchedule[dayKey];
                        const row = document.createElement('tr');

                        const dayCell = document.createElement('td');
                        dayCell.textContent = getFullDayName(dayKey);
                        dayCell.classList.add('day-header');
                        row.appendChild(dayCell);

                        timeHeaders.forEach(timeSlotKey => {
                            const cell = document.createElement('td');
                            const entries = dayData[timeSlotKey] || [];
                            if (entries.length > 0) {
                                const ul = document.createElement('ul');
                                ul.classList.add('schedule-entry');
                                entries.forEach(entryText => {
                                    const li = document.createElement('li');
                                    li.textContent = entryText;
                                    ul.appendChild(li);
                                    if (typeof entryText === 'string' && entryText.toUpperCase().includes("REHAT")) {
                                        cell.classList.add('rehat-cell');
                                    }
                                });
                                cell.appendChild(ul);
                            }
                            row.appendChild(cell);
                        });
                        tbody.appendChild(row);
                    }
                });

                table.appendChild(tbody);
                outputDiv.appendChild(table);
            }
        }

        function getFullDayName(dayKey) {
            const names = { "Mo": "Monday", "Tu": "Tuesday", "We": "Wednesday", "Th": "Thursday", "Fr": "Friday" };
            return names[dayKey] || dayKey;
        }

        async function processPdf() {
            const fileInput = document.getElementById('pdfFile');
            if (fileInput.files.length === 0) {
                setStatus("Please select a PDF file first.", true);
                return;
            }
            const file = fileInput.files[0];
            setStatus(`Processing PDF "${file.name}"... this may take a moment.`);

            const reader = new FileReader();
            reader.onload = async function(event) {
                try {
                    const typedarray = new Uint8Array(event.target.result);
                    const pdfDoc = await pdfjsLib.getDocument({ data: typedarray }).promise;
                    const numPages = pdfDoc.numPages;
                    let allTeachersData = {};

                    for (let i = 1; i <= numPages; i++) {
                        setStatus(`Processing page ${i} of ${numPages}...`);
                        const page = await pdfDoc.getPage(i);
                        const viewport = page.getViewport({ scale: 1.5 });
                        const textContent = await page.getTextContent({ normalizeWhitespace: true });
                        
                        const items = textContent.items.map(item => {
                            const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                            return {
                                text: item.str,
                                x: tx[4],
                                y: viewport.height - tx[5],
                                width: item.width * viewport.scale,
                                height: item.height * viewport.scale,
                                fontName: item.fontName
                            };
                        }).sort((a,b) => a.y - b.y || a.x - b.x);

                        const teacherName = extractTeacherNameJS(items, viewport.height); // Pass viewport.height
                        
                        if (teacherName && !allTeachersData[teacherName]) {
                            // console.log(`Page ${i}: Found Teacher - ${teacherName}`);
                            const dayLabels = getDayLabelsJS(items, viewport.height);
                            const timeSlotDefinitions = getTimeSlotDefinitionsJS(items, viewport.height);

                            if (dayLabels.length > 0 && timeSlotDefinitions.length > 0) {
                                allTeachersData[teacherName] = extractScheduleJS(items, dayLabels, timeSlotDefinitions, teacherName, viewport.height);
                            } else {
                                console.warn(`Page ${i} for ${teacherName}: Missing day or time labels. DayL: ${dayLabels.length}, TimeL: ${timeSlotDefinitions.length}`);
                            }
                        } else if (teacherName) {
                             console.warn(`Page ${i}: Teacher ${teacherName} might be a duplicate or already processed.`);
                        } else {
                            console.warn(`No teacher name found on page ${i}`); // This is what the user is seeing
                        }
                    }

                    if (Object.keys(allTeachersData).length > 0) {
                        displaySchedules(allTeachersData);
                        setStatus(`PDF "${file.name}" processed and displayed.`);
                    } else {
                        setStatus(`Could not extract any schedule data from PDF "${file.name}". Check console for details.`, true);
                    }

                } catch (e) {
                    setStatus(`Error processing PDF: ${e.message}`, true);
                    console.error("Error processing PDF:", e);
                }
            };
            reader.onerror = function() {
                setStatus(`Error reading PDF file: ${reader.error}`, true);
            };
            reader.readAsArrayBuffer(file);
        }

        // --- JS Re-implementations of Python extraction logic (REVISED) ---
        function extractTeacherNameJS(items, pageViewportHeight) {
            let nameParts = [];
            let collectingName = false;
            let lastItemYForName = 0;
            const MAX_Y_FOR_NAME_HEADER = pageViewportHeight * 0.18; // Top 18% of page for "NAMA GURU:"
            const MAX_Y_FOR_NAME_COLLECTION = pageViewportHeight * 0.25; // Stop collecting name below this

            // For debugging:
            // items.filter(it => it.y < MAX_Y_FOR_NAME_COLLECTION * 1.2).forEach(it => console.log(`Item: "${it.text}" (y: ${it.y.toFixed(0)}, x: ${it.x.toFixed(0)})`));

            let keywordLineY = -1; // Y-coordinate of the line where "NAMA GURU" was found

            // First pass: find "NAMA GURU"
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.y > MAX_Y_FOR_NAME_HEADER) continue; // Only look in header area

                const upperText = item.text.toUpperCase();
                if (upperText.includes("NAMA")) {
                    let combinedText = upperText;
                    let lastX = item.x + item.width;
                    keywordLineY = item.y; // Y of "NAMA"

                    // Look ahead for "GURU" on roughly the same line
                    for (let j = i + 1; j < Math.min(i + 8, items.length); j++) {
                        const nextItem = items[j];
                        if (Math.abs(nextItem.y - keywordLineY) < item.height * 0.8 && nextItem.x > lastX - 10 && nextItem.x < lastX + 70) { // Tolerate some overlap or small gap
                            combinedText += " " + nextItem.text.toUpperCase();
                            lastX = nextItem.x + nextItem.width;
                            if (combinedText.includes("NAMA GURU")) {
                                collectingName = true;
                                // Extract part after "NAMA GURU:" from combinedText or subsequent items
                                let nameCandidate = combinedText.substring(combinedText.indexOf("NAMA GURU") + "NAMA GURU".length);
                                nameCandidate = nameCandidate.replace(/^[:\s]+/, ""); // Remove leading colon/space
                                if (nameCandidate) {
                                    nameCandidate.split(/\s+/).forEach(p => {
                                        if (p && p.length > 0) nameParts.push(p);
                                    });
                                }
                                lastItemYForName = keywordLineY; // Set Y reference for collecting more parts
                                i = j; // Advance main loop index
                                break; // Found "NAMA GURU"
                            }
                        } else if (nextItem.y > keywordLineY + item.height) { // Moved to next line
                            break;
                        }
                    }
                }
                 if (collectingName) break; // Found keyword, proceed to collect actual name parts
            }
            
            // Second pass (or continuation): Collect actual name parts if keyword was found
            if (collectingName) {
                // Start collecting from items after where "NAMA GURU" was identified,
                // or from the beginning if "TEACHER" was used (simplified for now).
                // The loop `i` is already advanced.
                let startCollectingIndex = 0; // Find where to start collecting name parts
                for(let k=0; k < items.length; k++){
                    if(items[k].y >= keywordLineY - items[k].height*0.5 && items[k].y <= keywordLineY + items[k].height*0.5){
                         // If "NAMA GURU" was part of this item, split and take remainder
                         const upperItemText = items[k].text.toUpperCase();
                         if(upperItemText.includes("NAMA GURU")){
                             let potentialName = items[k].text.substring(upperItemText.indexOf("NAMA GURU") + "NAMA GURU".length).replace(/^[:\s]+/, "");
                             if(potentialName.trim()){ nameParts = potentialName.trim().split(/\s+/); }
                             startCollectingIndex = k + 1;
                             lastItemYForName = items[k].y;
                             break;
                         }
                    }
                    if(items[k].y > keywordLineY + items[k].height*1.5) break; // Don't search too far down
                }


                for (let k = startCollectingIndex; k < items.length; k++) {
                    const item = items[k];
                    const upperText = item.text.toUpperCase().trim();

                    if (item.y > MAX_Y_FOR_NAME_COLLECTION && nameParts.length > 0) break;
                    if (nameParts.length > 0 && item.y > lastItemYForName + item.height * 1.5) break; // New line too far

                    if (upperText.includes("REHAT") || upperText.includes("ASSEMBLY") ||
                        item.text.match(/\d{1,2}:\d{2}/) || upperText.startsWith("SMK") || upperText.includes("SESI PAGI")) {
                        break;
                    }

                    if (item.text && item.text.length > 0 && !item.text.match(/^\W+$/) && nameParts.length < 8) {
                        if (Math.abs(item.y - lastItemYForName) < item.height * 1.2 || nameParts.length === 0) { // Same line or first part
                            if (item.text.length > 1 || (item.text.length === 1 && /[A-ZÀ-ÖØ-öø-ſ]/.test(item.text))) {
                               // Check if part of "NAMA GURU:" itself
                                if(!(upperText.includes("NAMA") || upperText.includes("GURU"))){
                                    nameParts.push(item.text);
                                }
                            }
                            lastItemYForName = item.y;
                        }
                    }
                    if (nameParts.length >= 7) break;
                }
            }


            if (nameParts.length === 0) return null;

            let fullName = nameParts.join(" ").replace(/[:,-]/g, "").trim().toUpperCase();
            
            const noiseParts = [
                "NAMA GURU", "GURU", // Ensure these are removed if they sneak in
                "SMK SERI PULAI PERDANA", "JOHOR BAHRU", "SMK", "SERI PULAI PERDANA",
                "SESI PAGI BIL. 1 2025", "SESI PAGI BIL 1 2025", "SESI PAGI BIL.", "BIL. 1 2025", "BIL 1 2025", "1 2025",
                "JADUAL WAKTU", "MORNING ASSEMBLY", "REHAT"
            ];
            noiseParts.forEach(part => {
                const regex = new RegExp(part.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\s+/g, '\\s*'), "gi");
                fullName = fullName.replace(regex, "").trim();
            });
            fullName = fullName.replace(/^[:\s]+|[:\s]+$/g, "");

            return fullName && fullName.length > 3 ? fullName : null;
        }


        function getDayLabelsJS(items, pageHeight) {
            const dayLabels = [];
            const pdfDays = ["Mo", "Tu", "We", "Th", "Fr"];
            // Adjust y-range: days appear below the main headers but above the footer.
            const MIN_Y_FOR_DAY = pageHeight * 0.20; // Approx start of schedule rows
            const MAX_Y_FOR_DAY = pageHeight * 0.90; // Approx end of schedule rows

            for (const item of items) {
                if (pdfDays.includes(item.text) && item.x < pageHeight * 0.1) { // Days are on the far left (e.g., < 10% of page height for x)
                    if(item.y > MIN_Y_FOR_DAY && item.y < MAX_Y_FOR_DAY) { 
                        let existing = dayLabels.find(d => d.day === item.text);
                        if (!existing) {
                             dayLabels.push({ day: item.text, y_center: item.y + item.height / 2, y0: item.y, y1: item.y + item.height });
                        } else { 
                            existing.y0 = Math.min(existing.y0, item.y);
                            existing.y1 = Math.max(existing.y1, item.y + item.height);
                            existing.y_center = (existing.y0 + existing.y1) / 2;
                        }
                    }
                }
            }
            return dayLabels.sort((a,b) => a.y_center - b.y_center);
        }

        function getTimeSlotDefinitionsJS(items, pageHeight) {
            const timeSlotDefs = [];
             // Y-range for time headers, typically above the day rows
            const MIN_Y_FOR_TIME_HEADER = pageHeight * 0.15;
            const MAX_Y_FOR_TIME_HEADER = pageHeight * 0.25; // More constrained y-range
            
            const headerItems = items.filter(it => 
                it.y > MIN_Y_FOR_TIME_HEADER && it.y < MAX_Y_FOR_TIME_HEADER && 
                it.text.match(/^\d{1,2}:\d{2}$/)
            ); 

            const timeXPositions = {}; 
            headerItems.forEach(item => {
                let timeStr = item.text.split(':').map(p => p.padStart(2, '0')).join(':'); 
                // Handle cases like "7:15" becoming "07:15"
                if (timeStr.match(/^\d:\d{2}$/)) timeStr = "0" + timeStr;

                if (!timeXPositions[timeStr]) timeXPositions[timeStr] = [];
                timeXPositions[timeStr].push({ text: item.text, x: item.x, width: item.width, center: item.x + item.width / 2 });
            });

            for (const time in timeXPositions) {
                timeXPositions[time].sort((a,b) => a.x - b.x);
            }
            
            EXPECTED_TIME_SLOTS_KEYS.forEach(slotKey => {
                const [startStrFull, endStrFull] = slotKey.split('-');
                
                const startPositions = timeXPositions[startStrFull];
                
                if (startPositions && startPositions.length > 0) {
                    let chosenStartPosition = startPositions[0]; // Default to the first one found for this time string

                    // Heuristic for "09:45" which can appear multiple times for different slots
                    if (startStrFull === "09:45" && startPositions.length > 1) {
                        if (slotKey === "09:45-10:00") { // This slot is usually the *second* "09:45" if "09:45-10:15" (REHAT) also exists
                           // Find the "09:45" instance that is immediately before "10:00"
                           const tenOClockPos = timeXPositions["10:00"];
                           if (tenOClockPos && tenOClockPos.length > 0) {
                               let bestNine45 = startPositions[0];
                               let minDist = Infinity;
                               startPositions.forEach(sp => {
                                   if (sp.x < tenOClockPos[0].x) { // Must be before 10:00
                                       let dist = tenOClockPos[0].x - (sp.x + sp.width);
                                       if (dist >= 0 && dist < minDist) {
                                           minDist = dist;
                                           bestNine45 = sp;
                                       }
                                   }
                               });
                               chosenStartPosition = bestNine45;
                           } else { // Fallback if 10:00 isn't clearly found
                               chosenStartPosition = startPositions[startPositions.length -1]; // Guess the rightmost 09:45
                           }
                        } // else for "09:45-10:15", the default first one is usually correct
                    }


                    let slotX0 = chosenStartPosition.x - 2; // Adjusted padding
                    let slotX1;

                    if (slotKey === "09:45-10:15" && timeXPositions["10:15"] && timeXPositions["10:15"].length > 0) { 
                        slotX1 = timeXPositions["10:15"][0].x + timeXPositions["10:15"][0].width + 2;
                    } else if (slotKey === "10:30-11:00" && timeXPositions["10:30"] && timeXPositions["11:00"] && timeXPositions["10:30"].length > 0 && timeXPositions["11:00"].length > 0) { 
                        slotX0 = timeXPositions["10:30"][0].x - 2; 
                        slotX1 = timeXPositions["11:00"][0].x + timeXPositions["11:00"][0].width + 2;
                    } else if (timeXPositions[endStrFull] && timeXPositions[endStrFull].length > 0) {
                        const suitableEndPos = timeXPositions[endStrFull].find(ep => ep.x > chosenStartPosition.x);
                        if (suitableEndPos) {
                           const startH = parseInt(startStrFull.split(':')[0]);
                           const startM = parseInt(startStrFull.split(':')[1]);
                           const endH = parseInt(endStrFull.split(':')[0]);
                           const endM = parseInt(endStrFull.split(':')[1]);
                           const durationMinutes = (endH - startH) * 60 + (endM - startM);

                           if (durationMinutes === 15) {
                               slotX1 = suitableEndPos.x + 2; // End at start of the end-time text for 15-min
                           } else { 
                               slotX1 = suitableEndPos.x + suitableEndPos.width + 2;
                           }
                        } else {
                             slotX1 = chosenStartPosition.x + chosenStartPosition.width + 30; // Fallback: approx 30px width for a slot segment
                        }
                    } else { // Fallback if end time string not found in header for x-pos
                        slotX1 = chosenStartPosition.x + chosenStartPosition.width + 30; 
                    }
                    if (slotX1 > slotX0) { // Ensure x1 is actually after x0
                        timeSlotDefs.push({ time_slot_key: slotKey, x0: slotX0, x1: slotX1 });
                    }
                }
            });
            
            const finalDefs = [];
            const addedKeys = new Set();
            // Sort by the predefined order of keys to ensure consistency
            EXPECTED_TIME_SLOTS_KEYS.forEach(expectedKey => {
                const foundDef = timeSlotDefs.find(def => def.time_slot_key === expectedKey);
                if (foundDef && !addedKeys.has(expectedKey)) {
                    finalDefs.push(foundDef);
                    addedKeys.add(expectedKey);
                }
            });
            // Add any remaining defs that might have been found but not in expected (shouldn't happen with current logic)
            timeSlotDefs.forEach(def => {
                if(!addedKeys.has(def.time_slot_key)){
                    finalDefs.push(def);
                    addedKeys.add(def.time_slot_key);
                }
            });

            return finalDefs;
        }

        function extractScheduleJS(items, dayLabels, timeSlotDefinitions, teacherNameFull, pageHeight) {
            const schedule = {};
            DAYS_ORDER.forEach(dKey => {
                schedule[dKey] = {};
                EXPECTED_TIME_SLOTS_KEYS.forEach(tsKey => schedule[dKey][tsKey] = []);
            });

            const teacherNameTokensArray = teacherNameFull.toUpperCase().split(/\s+/)
                .map(p => p.replace(/[^A-Z0-9À-ÖØ-öø-ſ]/gi, '')) // Allow more characters for names
                .filter(p => p.length > 1 && !["BIN", "BINTI", "A/L", "A/P", "BT", "BTE"].includes(p));
            const teacherNameTokens = new Set(teacherNameTokensArray);
            
            const commonSubjectCodes = ["PH", "KOKO", "P", "SJ", "MM", "BI", "SN", "BM", "RBT", "ASK", "PM", "PI", "PS", "PA", "PJ", "GE", "FIZ", "KIM", "BIO", "MMT", "MT", "SEJ", "REHAT", "TAW", "IV", "BC"];


            const itemsByCell = {}; 
            const MIN_Y_FOR_CONTENT = pageHeight * 0.22; // Below time headers
            const MAX_Y_FOR_CONTENT = pageHeight * 0.90; // Above footer

            for (const item of items) {
                if (item.y < MIN_Y_FOR_CONTENT || item.y > MAX_Y_FOR_CONTENT) continue;
                
                const itemTextUpper = item.text.toUpperCase();
                let isPartOfTeacherNameDisplay = false;

                // Check if the current item text strongly suggests it's part of the teacher's name in a cell
                // (e.g., "PN.", "EN." followed by a known name token, or a name token itself)
                // This is hard to do perfectly without context of surrounding items in the cell.
                // A simpler check: if the item text, when cleaned, is one of the teacher's name tokens
                // and it's NOT a common subject code.
                const cleanedItemForNameCheck = itemTextUpper.replace(/[^A-Z0-9À-ÖØ-öø-ſ]/gi, '');
                if (teacherNameTokens.has(cleanedItemForNameCheck) && !commonSubjectCodes.includes(itemTextUpper)) {
                    isPartOfTeacherNameDisplay = true;
                }
                // Also filter out titles if they are likely part of the name
                const commonTitlesNoDot = ["EN", "PN", "CIK", "UST", "DR", "MR"];
                 if (commonTitlesNoDot.includes(itemTextUpper.replace('.',''))) {
                    // Check if a name token follows, this requires looking at items already grouped in cell.
                    // For now, if it's a title, assume it MIGHT be part of name display and be cautious.
                    // This is too aggressive if titles are also subject codes.
                 }


                if (isPartOfTeacherNameDisplay) continue;


                for (const dayLabel of dayLabels) {
                    // Check if item's y-center is within day's vertical band
                    const itemYCenter = item.y + item.height / 2;
                    if (itemYCenter >= dayLabel.y0 && itemYCenter <= dayLabel.y1 + 5) { // +5 for tolerance
                        for (const slotDef of timeSlotDefinitions) {
                            const itemXCenter = item.x + item.width / 2;
                            if (itemXCenter >= slotDef.x0 && itemXCenter <= slotDef.x1) {
                                const cellKey = `${dayLabel.day}_${slotDef.time_slot_key}`;
                                if (!itemsByCell[cellKey]) itemsByCell[cellKey] = [];
                                if (item.text.trim() && !item.text.match(/^\d{1,2}:\d{2}$/)) { // Not empty & not a time string
                                   itemsByCell[cellKey].push({text: item.text.trim(), x: item.x, y: item.y, height: item.height});
                                }
                                break; 
                            }
                        }
                    }
                }
            }

            for(const cellKey in itemsByCell){
                const [day, slot] = cellKey.split('_');
                const cellItems = itemsByCell[cellKey];
                if (cellItems.length === 0) continue;

                // Group by approximate line (y-coordinate)
                const lines = {};
                cellItems.sort((a,b) => a.y - b.y || a.x - b.x); // Pre-sort for easier line grouping

                cellItems.forEach(itm => {
                    let foundLineKey = null;
                    for (const lineYStr in lines) {
                        const lineAvgY = parseFloat(lineYStr);
                        // Check if item's y is close to the average y of an existing line
                        if (Math.abs(itm.y - lineAvgY) < itm.height * 0.7) { 
                            foundLineKey = lineYStr;
                            break;
                        }
                    }
                    if (foundLineKey) {
                        lines[foundLineKey].push(itm);
                        // Optional: re-calculate lineAvgY if needed, but simple grouping by first item's y is often enough
                    } else {
                        lines[itm.y.toFixed(1)] = [itm]; // Use toFixed to group close y values
                    }
                });

                let fullCellTextEntries = [];
                Object.keys(lines).sort((a,b) => parseFloat(a) - parseFloat(b)).forEach(lineYStr => {
                    const lineText = lines[lineYStr].sort((a,b) => a.x - b.x).map(itm => itm.text).join(" ");
                    if (lineText.trim()) {
                        fullCellTextEntries.push(lineText.trim());
                    }
                });
                
                if(fullCellTextEntries.length > 0) {
                     schedule[day][slot] = fullCellTextEntries;
                }
            }
            return schedule;
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadAndDisplayJson(DEFAULT_JSON_PATH, `default schedule (${DEFAULT_JSON_PATH})`);
        });

    </script>
</body>
</html>