<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher Schedule Viewer</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #2c3e50;
            text-align: center;
        }
        h2 {
            margin-top: 30px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #e9ecef;
            font-weight: bold;
        }
        td.day-header {
            font-weight: bold;
            background-color: #f8f9fa;
            width: 80px; /* Fixed width for Day column */
        }
        .rehat-cell {
            background-color: #e6ffed; /* Light green for REHAT */
            color: #28a745;
            font-weight: bold;
            text-align: center;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
        }
        .controls label {
            margin-right: 10px;
            font-weight: bold;
        }
        .controls input[type="file"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .controls button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        #statusArea {
            margin-top: 15px;
            font-style: italic;
            color: #555;
            text-align: center;
        }
        .schedule-entry {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .schedule-entry li {
            padding: 2px 0;
        }
    </style>
    <!-- PDF.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script>
        // Set workerSrc for pdf.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
    </script>
</head>
<body>
    <div class="container">
        <h1>Teacher Schedule Viewer</h1>

        <div class="controls">
            <label for="jsonFileManual">Load Another JSON File:</label>
            <input type="file" id="jsonFileManual" accept=".json">
            <button onclick="loadJsonFromManualFile()">Load JSON</button>
            <br><br>
            <label for="pdfFile">Import PDF File (for new extraction):</label>
            <input type="file" id="pdfFile" accept=".pdf">
            <button onclick="processPdf()">Process PDF</button>
        </div>

        <div id="statusArea">Attempting to load default schedule...</div>
        <div id="scheduleOutput">
            <!-- Tables will be rendered here -->
        </div>
    </div>

    <script>
        const DEFAULT_JSON_PATH = 'teacher_schedules.json';
        const DAYS_ORDER = ["Mo", "Tu", "We", "Th", "Fr"];
        const EXPECTED_TIME_SLOTS_KEYS = [
            "07:15-07:45", "07:45-08:15", "08:15-08:45", "08:45-09:15", "09:15-09:45",
            "09:45-10:00", "09:45-10:15", "10:00-10:30", "10:15-10:30", "10:30-11:00",
            "11:00-11:30", "11:30-12:00", "12:00-12:30", "12:30-13:00", "13:00-13:30",
            "13:30-14:00", "14:00-14:30", "14:30-15:00", "15:00-15:30"
        ];

        function setStatus(message, isError = false) {
            const statusArea = document.getElementById('statusArea');
            statusArea.textContent = message;
            statusArea.style.color = isError ? 'red' : '#555';
        }

        async function loadAndDisplayJson(filePath, sourceDescription) {
            setStatus(`Loading ${sourceDescription}...`);
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} while fetching ${filePath}`);
                }
                const jsonData = await response.json();
                displaySchedules(jsonData);
                setStatus(`${sourceDescription} loaded and displayed.`);
            } catch (e) {
                setStatus(`Error loading or parsing ${sourceDescription}: ${e.message}`, true);
                console.error(`Error with ${sourceDescription}:`, e);
                if (sourceDescription.includes("default")) {
                     document.getElementById('scheduleOutput').innerHTML = `<p>Could not load default schedule from ${DEFAULT_JSON_PATH}. You can try loading another JSON file manually or processing a PDF.</p>`;
                }
            }
        }

        function loadJsonFromManualFile() {
            const fileInput = document.getElementById('jsonFileManual');
            if (fileInput.files.length === 0) {
                setStatus("Please select a JSON file first.", true);
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const jsonData = JSON.parse(event.target.result);
                    displaySchedules(jsonData);
                    setStatus(`JSON file "${file.name}" loaded and displayed.`);
                } catch (e) {
                    setStatus(`Error parsing JSON file "${file.name}": ${e.message}`, true);
                    console.error("Error parsing JSON:", e);
                }
            };
            reader.onerror = function() {
                setStatus(`Error reading file "${file.name}": ${reader.error}`, true);
            };
            reader.readAsText(file);
        }

        function displaySchedules(allTeachersData) {
            const outputDiv = document.getElementById('scheduleOutput');
            outputDiv.innerHTML = ''; 

            if (!allTeachersData || Object.keys(allTeachersData).length === 0) {
                outputDiv.innerHTML = '<p>No schedule data to display.</p>';
                return;
            }

            const timeHeaders = [...EXPECTED_TIME_SLOTS_KEYS];

            for (const teacherName in allTeachersData) {
                const teacherSchedule = allTeachersData[teacherName];

                const teacherHeader = document.createElement('h2');
                teacherHeader.textContent = teacherName;
                outputDiv.appendChild(teacherHeader);

                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                const headerRow = document.createElement('tr');
                const dayTh = document.createElement('th');
                dayTh.textContent = 'Day';
                headerRow.appendChild(dayTh);

                timeHeaders.forEach(timeSlot => {
                    const th = document.createElement('th');
                    th.textContent = timeSlot.replace('-', ' - ');
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                DAYS_ORDER.forEach(dayKey => {
                    if (teacherSchedule[dayKey]) {
                        const dayData = teacherSchedule[dayKey];
                        const row = document.createElement('tr');

                        const dayCell = document.createElement('td');
                        dayCell.textContent = getFullDayName(dayKey);
                        dayCell.classList.add('day-header');
                        row.appendChild(dayCell);

                        timeHeaders.forEach(timeSlotKey => {
                            const cell = document.createElement('td');
                            const entries = dayData[timeSlotKey] || [];
                            if (entries.length > 0) {
                                const ul = document.createElement('ul');
                                ul.classList.add('schedule-entry');
                                entries.forEach(entryText => {
                                    const li = document.createElement('li');
                                    li.textContent = entryText;
                                    ul.appendChild(li);
                                    if (typeof entryText === 'string' && entryText.toUpperCase().includes("REHAT")) {
                                        cell.classList.add('rehat-cell');
                                    }
                                });
                                cell.appendChild(ul);
                            }
                            row.appendChild(cell);
                        });
                        tbody.appendChild(row);
                    }
                });

                table.appendChild(tbody);
                outputDiv.appendChild(table);
            }
        }

        function getFullDayName(dayKey) {
            const names = { "Mo": "Monday", "Tu": "Tuesday", "We": "Wednesday", "Th": "Thursday", "Fr": "Friday" };
            return names[dayKey] || dayKey;
        }

        async function processPdf() {
            const fileInput = document.getElementById('pdfFile');
            if (fileInput.files.length === 0) {
                setStatus("Please select a PDF file first.", true);
                return;
            }
            const file = fileInput.files[0];
            setStatus(`Processing PDF "${file.name}"... this may take a moment.`);

            const reader = new FileReader();
            reader.onload = async function(event) {
                try {
                    const typedarray = new Uint8Array(event.target.result);
                    const pdfDoc = await pdfjsLib.getDocument({ data: typedarray }).promise;
                    const numPages = pdfDoc.numPages;
                    let allTeachersData = {};

                    for (let i = 1; i <= numPages; i++) {
                        setStatus(`Processing page ${i} of ${numPages}...`);
                        const page = await pdfDoc.getPage(i);
                        const viewport = page.getViewport({ scale: 1.5 });
                        const textContent = await page.getTextContent({ normalizeWhitespace: true });
                        
                        const items = textContent.items.map(item => {
                            const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                            return {
                                text: item.str,
                                x: tx[4],
                                y: viewport.height - tx[5],
                                width: item.width * viewport.scale,
                                height: item.height * viewport.scale,
                                fontName: item.fontName // Keep fontName if needed for advanced logic
                            };
                        }).sort((a,b) => a.y - b.y || a.x - b.x); // Sort all items once

                        const teacherName = extractTeacherNameJS(items, viewport.height); 
                        
                        if (teacherName && !allTeachersData[teacherName]) { // Process if name found and not already added
                            // console.log(`Page ${i}: Found Teacher - ${teacherName}`); // For debugging
                            const dayLabels = getDayLabelsJS(items, viewport.height);
                            const timeSlotDefinitions = getTimeSlotDefinitionsJS(items, viewport.height);

                            if (dayLabels.length > 0 && timeSlotDefinitions.length > 0) {
                                allTeachersData[teacherName] = extractScheduleJS(items, dayLabels, timeSlotDefinitions, teacherName, viewport.height);
                            } else {
                                console.warn(`Page ${i} for ${teacherName}: Missing day or time labels. DayLabels: ${dayLabels.length}, TimeSlots: ${timeSlotDefinitions.length}`);
                            }
                        } else if (teacherName) { // Name found, but already in allTeachersData
                             console.warn(`Page ${i}: Teacher ${teacherName} might be a duplicate or already processed.`);
                        } else { // No name found on this page
                            console.warn(`No teacher name found on page ${i}`);
                        }
                    }

                    if (Object.keys(allTeachersData).length > 0) {
                        displaySchedules(allTeachersData);
                        setStatus(`PDF "${file.name}" processed and displayed.`);
                    } else {
                        setStatus(`Could not extract any schedule data from PDF "${file.name}". Check console for details.`, true);
                    }

                } catch (e) {
                    setStatus(`Error processing PDF: ${e.message}`, true);
                    console.error("Error processing PDF:", e);
                }
            };
            reader.onerror = function() {
                setStatus(`Error reading PDF file: ${reader.error}`, true);
            };
            reader.readAsArrayBuffer(file);
        }
        
        // --- START OF REVISED extractTeacherNameJS ---
        function extractTeacherNameJS(items, pageViewportHeight) {
            let nameParts = [];
            let collectingName = false;
            let startCollectingFromIndex = -1;
            let referenceYForName = 0;

            const MAX_Y_FOR_KEYWORD = pageViewportHeight * 0.20; // Keywords should be in the top 20%

            // Uncomment for detailed debugging of items in the header region
            // console.log("--- extractTeacherNameJS: Items in header region ---");
            // items.filter(it => it.y < MAX_Y_FOR_KEYWORD * 1.5).forEach(it => console.log(`  Item: "${it.text}" (y: ${it.y.toFixed(0)}, x: ${it.x.toFixed(0)})`));

            // Phase 1: Find the "NAMA GURU:" sequence
            for (let i = 0; i < items.length; i++) {
                if (items[i].y > MAX_Y_FOR_KEYWORD) break; 

                const item1 = items[i];
                const text1Upper = item1.text.toUpperCase();

                if (text1Upper.includes("NAMA")) {
                    // console.log(`Found "NAMA" in "${item1.text}" at index ${i}, y: ${item1.y.toFixed(1)}`);
                    let fullKeywordSequence = text1Upper;
                    let lastKeywordItemIndex = i;

                    // Look for "GURU" or "GURU:" in the next few items on a similar line
                    for (let j = i + 1; j < Math.min(i + 5, items.length); j++) { 
                        const item2 = items[j];
                        if (Math.abs(item2.y - item1.y) < item1.height * 0.8 && item2.x > items[lastKeywordItemIndex].x) { // Similar line and generally progressing right
                            fullKeywordSequence += " " + item2.text.toUpperCase();
                            lastKeywordItemIndex = j;
                            if (fullKeywordSequence.includes("NAMA GURU")) {
                                // console.log(`  "NAMA GURU" sequence confirmed: "${fullKeywordSequence}" ending at index ${j}`);
                                collectingName = true;
                                referenceYForName = item1.y; // Y of the line where NAMA GURU started
                                
                                // Try to extract initial name part if it's on the same line immediately after "NAMA GURU:"
                                let combinedTextForKeywordAndInitialName = "";
                                for (let k=i; k <= lastKeywordItemIndex; k++) {
                                    combinedTextForKeywordAndInitialName += items[k].text + " ";
                                }
                                combinedTextForKeywordAndInitialName = combinedTextForKeywordAndInitialName.trim();

                                let nameStartsAfter = combinedTextForKeywordAndInitialName.toUpperCase().indexOf("NAMA GURU");
                                if (nameStartsAfter !== -1) {
                                    let potentialNameStart = combinedTextForKeywordAndInitialName.substring(nameStartsAfter + "NAMA GURU".length);
                                    potentialNameStart = potentialNameStart.replace(/^[:\s]+/, "").trim(); // Remove leading colon/space
                                    if (potentialNameStart) {
                                        nameParts.push(...potentialNameStart.split(/\s+/).filter(p => p));
                                        // console.log(`  Pushed initial parts from keyword line: ${nameParts.join(' ')}`);
                                    }
                                }
                                startCollectingFromIndex = lastKeywordItemIndex + 1;
                                break; 
                            }
                        } else if (item2.y > item1.y + item1.height * 1.5) { 
                            break;
                        }
                    }
                }
                if (collectingName) break; 
            }

            // Phase 2: Collect the name parts if "NAMA GURU:" was found
            if (collectingName && startCollectingFromIndex !== -1) {
                // console.log(`Starting name collection from index ${startCollectingFromIndex}, referenceY: ${referenceYForName.toFixed(1)}`);
                let lastCollectedY = referenceYForName;

                for (let i = startCollectingFromIndex; i < items.length; i++) {
                    const item = items[i];
                    const upperText = item.text.toUpperCase().trim();

                    if (item.y > referenceYForName + item.height * 2.5 && nameParts.length > 0) {
                        // console.log(`  Stopping: y jump. Current item y: ${item.y.toFixed(1)}, text: "${item.text}"`);
                        break;
                    }
                    if (upperText.startsWith("SMK") || upperText.includes("SESI PAGI") ||
                        upperText.includes("REHAT") || upperText.includes("ASSEMBLY") ||
                        item.text.match(/\d{1,2}:\d{2}/)) { 
                        // console.log(`  Stopping: Found stop keyword "${upperText}"`);
                        break;
                    }
                    if (nameParts.length >= 7) {
                        // console.log("  Stopping: Max name parts reached.");
                        break;
                    }

                    if (item.text && item.text.length > 0 && !item.text.match(/^\W+$/)) { 
                        if (Math.abs(item.y - lastCollectedY) < item.height * 1.2 || (nameParts.length === 0 && Math.abs(item.y - referenceYForName) < item.height * 1.2) ) {
                            if (item.text.length > 1 || (item.text.length === 1 && /[A-ZÀ-ÖØ-öø-ſ]/i.test(item.text))) { 
                                if (!upperText.startsWith("NAMA") && !upperText.startsWith("GURU") && upperText !== ":" && !upperText.includes("JADUAL WAKTU")) { // Added JADUAL WAKTU
                                    nameParts.push(item.text);
                                    lastCollectedY = item.y; 
                                    // console.log(`    Collected: "${item.text}", Parts now: ${nameParts.join(' ')}`);
                                }
                            }
                        } else if (nameParts.length > 0 && item.y > lastCollectedY + item.height * 1.5) {
                            // console.log(`  Stopping: New line too far. Item y: ${item.y.toFixed(1)}, lastCollectedY: ${lastCollectedY.toFixed(1)}`);
                            break; 
                        }
                    }
                }
            }

            if (nameParts.length === 0) {
                // console.log("No name parts collected.");
                return null;
            }

            let fullName = nameParts.join(" ").replace(/[:,-]/g, "").trim().toUpperCase();
            // console.log("Raw full name before cleaning:", fullName);

            const noiseParts = [
                "NAMA GURU", "GURU", "TEACHER", "JADUAL WAKTU SESI PAGI BIL 1 2025",
                "SMK SERI PULAI PERDANA", "JOHOR BAHRU", "SERI PULAI PERDANA", "PULAI PERDANA",
                "SESI PAGI BIL 1 2025", "SESI PAGI BIL.", "BIL 1 2025", "1 2025", "2025",
                "MORNING ASSEMBLY", "REHAT"
            ];
            
            noiseParts.forEach(part => {
                const regex = new RegExp(part.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\s+/g, '\\s*'), "gi");
                fullName = fullName.replace(regex, "").trim();
            });
            fullName = fullName.replace(/^[:\s]+|[:\s]+$/g, ""); 

            // console.log("Final cleaned name:", fullName);
            return fullName && fullName.length > 3 ? fullName : null; 
        }
        // --- END OF REVISED extractTeacherNameJS ---


        function getDayLabelsJS(items, pageHeight) {
            const dayLabels = [];
            const pdfDays = ["Mo", "Tu", "We", "Th", "Fr"];
            const MIN_Y_FOR_DAY = pageHeight * 0.20; 
            const MAX_Y_FOR_DAY = pageHeight * 0.90; 

            for (const item of items) {
                if (pdfDays.includes(item.text) && item.x < pageHeight * 0.1) { 
                    if(item.y > MIN_Y_FOR_DAY && item.y < MAX_Y_FOR_DAY) { 
                        let existing = dayLabels.find(d => d.day === item.text);
                        if (!existing) {
                             dayLabels.push({ day: item.text, y_center: item.y + item.height / 2, y0: item.y, y1: item.y + item.height });
                        } else { 
                            existing.y0 = Math.min(existing.y0, item.y);
                            existing.y1 = Math.max(existing.y1, item.y + item.height);
                            existing.y_center = (existing.y0 + existing.y1) / 2;
                        }
                    }
                }
            }
            return dayLabels.sort((a,b) => a.y_center - b.y_center);
        }

        function getTimeSlotDefinitionsJS(items, pageHeight) {
            const timeSlotDefs = [];
            const MIN_Y_FOR_TIME_HEADER = pageHeight * 0.15;
            const MAX_Y_FOR_TIME_HEADER = pageHeight * 0.25; 
            
            const headerItems = items.filter(it => 
                it.y > MIN_Y_FOR_TIME_HEADER && it.y < MAX_Y_FOR_TIME_HEADER && 
                it.text.match(/^\d{1,2}:\d{2}$/)
            ); 

            const timeXPositions = {}; 
            headerItems.forEach(item => {
                let timeStr = item.text.split(':').map(p => p.padStart(2, '0')).join(':'); 
                if (timeStr.match(/^\d:\d{2}$/)) timeStr = "0" + timeStr;

                if (!timeXPositions[timeStr]) timeXPositions[timeStr] = [];
                timeXPositions[timeStr].push({ text: item.text, x: item.x, width: item.width, center: item.x + item.width / 2 });
            });

            for (const time in timeXPositions) {
                timeXPositions[time].sort((a,b) => a.x - b.x);
            }
            
            EXPECTED_TIME_SLOTS_KEYS.forEach(slotKey => {
                const [startStrFull, endStrFull] = slotKey.split('-');
                
                const startPositions = timeXPositions[startStrFull];
                
                if (startPositions && startPositions.length > 0) {
                    let chosenStartPosition = startPositions[0]; 

                    if (startStrFull === "09:45" && startPositions.length > 1) {
                        if (slotKey === "09:45-10:00") { 
                           const tenOClockPos = timeXPositions["10:00"];
                           if (tenOClockPos && tenOClockPos.length > 0) {
                               let bestNine45 = startPositions[0];
                               let minDist = Infinity;
                               startPositions.forEach(sp => {
                                   if (sp.x < tenOClockPos[0].x) { 
                                       let dist = tenOClockPos[0].x - (sp.x + sp.width);
                                       if (dist >= 0 && dist < minDist && dist < 30) { // Ensure it's reasonably close before 10:00
                                           minDist = dist;
                                           bestNine45 = sp;
                                       }
                                   }
                               });
                               chosenStartPosition = bestNine45;
                           } else { 
                               chosenStartPosition = startPositions[startPositions.length -1]; 
                           }
                        } // else for "09:45-10:15", the default first one (leftmost) is usually correct
                    }


                    let slotX0 = chosenStartPosition.x - 2; 
                    let slotX1;

                    if (slotKey === "09:45-10:15" && timeXPositions["10:15"] && timeXPositions["10:15"].length > 0) { 
                        slotX1 = timeXPositions["10:15"][0].x + timeXPositions["10:15"][0].width + 2;
                    } else if (slotKey === "10:30-11:00" && timeXPositions["10:30"] && timeXPositions["11:00"] && timeXPositions["10:30"].length > 0 && timeXPositions["11:00"].length > 0) { 
                        slotX0 = timeXPositions["10:30"][0].x - 2; 
                        slotX1 = timeXPositions["11:00"][0].x + timeXPositions["11:00"][0].width + 2;
                    } else if (timeXPositions[endStrFull] && timeXPositions[endStrFull].length > 0) {
                        const suitableEndPos = timeXPositions[endStrFull].find(ep => ep.x > chosenStartPosition.x + chosenStartPosition.width - 5); // end must be after start's text
                        if (suitableEndPos) {
                           const startH = parseInt(startStrFull.split(':')[0]);
                           const startM = parseInt(startStrFull.split(':')[1]);
                           const endH = parseInt(endStrFull.split(':')[0]);
                           const endM = parseInt(endStrFull.split(':')[1]);
                           const durationMinutes = (endH - startH) * 60 + (endM - startM);

                           if (durationMinutes === 15) {
                               slotX1 = suitableEndPos.x + 2; 
                           } else { 
                               slotX1 = suitableEndPos.x + suitableEndPos.width + 2;
                           }
                        } else {
                             slotX1 = chosenStartPosition.x + chosenStartPosition.width + 30; 
                        }
                    } else { 
                        slotX1 = chosenStartPosition.x + chosenStartPosition.width + 30; 
                    }
                    if (slotX1 > slotX0) { 
                        timeSlotDefs.push({ time_slot_key: slotKey, x0: slotX0, x1: slotX1 });
                    }
                }
            });
            
            const finalDefs = [];
            const addedKeys = new Set();
            EXPECTED_TIME_SLOTS_KEYS.forEach(expectedKey => {
                const foundDef = timeSlotDefs.find(def => def.time_slot_key === expectedKey);
                if (foundDef && !addedKeys.has(expectedKey)) {
                    finalDefs.push(foundDef);
                    addedKeys.add(expectedKey);
                }
            });
            timeSlotDefs.forEach(def => { // Add any others not in expected (should not happen if logic is tight to EXPECTED_TIME_SLOTS_KEYS)
                if(!addedKeys.has(def.time_slot_key)){
                    finalDefs.push(def); // This case should ideally not be hit
                }
            });

            return finalDefs;
        }

        function extractScheduleJS(items, dayLabels, timeSlotDefinitions, teacherNameFull, pageHeight) {
            const schedule = {};
            DAYS_ORDER.forEach(dKey => {
                schedule[dKey] = {};
                EXPECTED_TIME_SLOTS_KEYS.forEach(tsKey => schedule[dKey][tsKey] = []);
            });

            const teacherNameTokensArray = teacherNameFull.toUpperCase().split(/\s+/)
                .map(p => p.replace(/[^A-Z0-9À-ÖØ-öø-ſ]/gi, '')) 
                .filter(p => p.length > 1 && !["BIN", "BINTI", "A/L", "A/P", "BT", "BTE"].includes(p));
            const teacherNameTokens = new Set(teacherNameTokensArray);
            
            const commonSubjectCodes = ["PH", "KOKO", "P", "SJ", "MM", "BI", "SN", "BM", "RBT", "ASK", "PM", "PI", "PS", "PA", "PJ", "GE", "FIZ", "KIM", "BIO", "MMT", "MT", "SEJ", "REHAT", "TAW", "IV", "BC"];

            const itemsByCell = {}; 
            const MIN_Y_FOR_CONTENT = pageHeight * 0.22; 
            const MAX_Y_FOR_CONTENT = pageHeight * 0.90; 

            for (const item of items) {
                if (item.y < MIN_Y_FOR_CONTENT || item.y > MAX_Y_FOR_CONTENT) continue;
                
                const itemTextUpper = item.text.toUpperCase();
                let isPartOfTeacherNameDisplay = false;
                const cleanedItemForNameCheck = itemTextUpper.replace(/[^A-Z0-9À-ÖØ-öø-ſ]/gi, '');

                if (teacherNameTokens.has(cleanedItemForNameCheck) && !commonSubjectCodes.includes(itemTextUpper)) {
                    // Further check: if the item is short and a common prefix like "EN." it's more likely part of name
                    if (itemTextUpper.length <= 3 && itemTextUpper.endsWith(".")) {
                        isPartOfTeacherNameDisplay = true;
                    } else if (itemTextUpper.length > 1) { // Avoid single letter common codes being filtered as name
                         isPartOfTeacherNameDisplay = true;
                    }
                }
                
                if (isPartOfTeacherNameDisplay) continue;

                for (const dayLabel of dayLabels) {
                    const itemYCenter = item.y + item.height / 2;
                    if (itemYCenter >= dayLabel.y0 && itemYCenter <= dayLabel.y1 + 5) { 
                        for (const slotDef of timeSlotDefinitions) {
                            const itemXCenter = item.x + item.width / 2;
                            if (itemXCenter >= slotDef.x0 && itemXCenter <= slotDef.x1) {
                                const cellKey = `${dayLabel.day}_${slotDef.time_slot_key}`;
                                if (!itemsByCell[cellKey]) itemsByCell[cellKey] = [];
                                if (item.text.trim() && !item.text.match(/^\d{1,2}:\d{2}$/)) { 
                                   itemsByCell[cellKey].push({text: item.text.trim(), x: item.x, y: item.y, height: item.height});
                                }
                                break; 
                            }
                        }
                    }
                }
            }

            for(const cellKey in itemsByCell){
                const [day, slot] = cellKey.split('_');
                const cellItems = itemsByCell[cellKey];
                if (cellItems.length === 0) continue;

                const lines = {};
                cellItems.sort((a,b) => a.y - b.y || a.x - b.x); 

                cellItems.forEach(itm => {
                    let foundLineKey = null;
                    for (const lineYStr in lines) {
                        const lineAvgY = parseFloat(lineYStr);
                        if (Math.abs(itm.y - lineAvgY) < itm.height * 0.7) { 
                            foundLineKey = lineYStr;
                            break;
                        }
                    }
                    if (foundLineKey) {
                        lines[foundLineKey].push(itm);
                    } else {
                        lines[itm.y.toFixed(1)] = [itm]; 
                    }
                });

                let fullCellTextEntries = [];
                Object.keys(lines).sort((a,b) => parseFloat(a) - parseFloat(b)).forEach(lineYStr => {
                    const lineText = lines[lineYStr].sort((a,b) => a.x - b.x).map(itm => itm.text).join(" ");
                    if (lineText.trim()) {
                        fullCellTextEntries.push(lineText.trim());
                    }
                });
                
                if(fullCellTextEntries.length > 0) {
                     schedule[day][slot] = fullCellTextEntries;
                }
            }
            return schedule;
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadAndDisplayJson(DEFAULT_JSON_PATH, `default schedule (${DEFAULT_JSON_PATH})`);
        });

    </script>
</body>
</html>