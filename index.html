<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher Schedule Viewer</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #2c3e50;
            text-align: center;
        }
        h2 {
            margin-top: 30px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #e9ecef;
            font-weight: bold;
        }
        td.day-header {
            font-weight: bold;
            background-color: #f8f9fa;
            width: 80px; /* Fixed width for Day column */
        }
        .rehat-cell {
            background-color: #e6ffed; /* Light green for REHAT */
            color: #28a745;
            font-weight: bold;
            text-align: center;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
        }
        .controls label {
            margin-right: 10px;
            font-weight: bold;
        }
        .controls input[type="file"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .controls button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        #statusArea {
            margin-top: 15px;
            font-style: italic;
            color: #555;
            text-align: center;
        }
        .schedule-entry {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .schedule-entry li {
            padding: 2px 0;
        }
    </style>
    <!-- PDF.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script>
        // Set workerSrc for pdf.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
    </script>
</head>
<body>
    <div class="container">
        <h1>Teacher Schedule Viewer</h1>

        <div class="controls">
            <label for="jsonFileManual">Load Another JSON File:</label>
            <input type="file" id="jsonFileManual" accept=".json">
            <button onclick="loadJsonFromManualFile()">Load JSON</button>
            <br><br>
            <label for="pdfFile">Import PDF File (for new extraction):</label>
            <input type="file" id="pdfFile" accept=".pdf">
            <button onclick="processPdf()">Process PDF</button>
        </div>

        <div id="statusArea">Attempting to load default schedule...</div>
        <div id="scheduleOutput">
            <!-- Tables will be rendered here -->
        </div>
    </div>

    <script>
        const DEFAULT_JSON_PATH = 'teacher_schedules.json';
        const DAYS_ORDER = ["Mo", "Tu", "We", "Th", "Fr"];
        const EXPECTED_TIME_SLOTS_KEYS = [
            "07:15-07:45", "07:45-08:15", "08:15-08:45", "08:45-09:15", "09:15-09:45",
            "09:45-10:00", "09:45-10:15", "10:00-10:30", "10:15-10:30", "10:30-11:00",
            "11:00-11:30", "11:30-12:00", "12:00-12:30", "12:30-13:00", "13:00-13:30",
            "13:30-14:00", "14:00-14:30", "14:30-15:00", "15:00-15:30"
        ];

        function setStatus(message, isError = false) {
            const statusArea = document.getElementById('statusArea');
            statusArea.textContent = message;
            statusArea.style.color = isError ? 'red' : '#555';
        }

        async function loadAndDisplayJson(filePath, sourceDescription) {
            setStatus(`Loading ${sourceDescription}...`);
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} while fetching ${filePath}`);
                }
                const jsonData = await response.json();
                displaySchedules(jsonData);
                setStatus(`${sourceDescription} loaded and displayed.`);
            } catch (e) {
                setStatus(`Error loading or parsing ${sourceDescription}: ${e.message}`, true);
                console.error(`Error with ${sourceDescription}:`, e);
                if (sourceDescription.includes("default")) {
                     document.getElementById('scheduleOutput').innerHTML = `<p>Could not load default schedule from ${DEFAULT_JSON_PATH}. You can try loading another JSON file manually or processing a PDF.</p>`;
                }
            }
        }

        function loadJsonFromManualFile() {
            const fileInput = document.getElementById('jsonFileManual');
            if (fileInput.files.length === 0) {
                setStatus("Please select a JSON file first.", true);
                return;
            }
            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const jsonData = JSON.parse(event.target.result);
                    displaySchedules(jsonData);
                    setStatus(`JSON file "${file.name}" loaded and displayed.`);
                } catch (e) {
                    setStatus(`Error parsing JSON file "${file.name}": ${e.message}`, true);
                    console.error("Error parsing JSON:", e);
                }
            };
            reader.onerror = function() {
                setStatus(`Error reading file "${file.name}": ${reader.error}`, true);
            };
            reader.readAsText(file);
        }

        function displaySchedules(allTeachersData) {
            const outputDiv = document.getElementById('scheduleOutput');
            outputDiv.innerHTML = ''; 

            if (!allTeachersData || Object.keys(allTeachersData).length === 0) {
                outputDiv.innerHTML = '<p>No schedule data to display.</p>';
                return;
            }

            const timeHeaders = [...EXPECTED_TIME_SLOTS_KEYS];

            for (const teacherName in allTeachersData) {
                const teacherSchedule = allTeachersData[teacherName];

                const teacherHeader = document.createElement('h2');
                teacherHeader.textContent = teacherName;
                outputDiv.appendChild(teacherHeader);

                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                const headerRow = document.createElement('tr');
                const dayTh = document.createElement('th');
                dayTh.textContent = 'Day';
                headerRow.appendChild(dayTh);

                timeHeaders.forEach(timeSlot => {
                    const th = document.createElement('th');
                    th.textContent = timeSlot.replace('-', ' - ');
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                DAYS_ORDER.forEach(dayKey => {
                    if (teacherSchedule[dayKey]) {
                        const dayData = teacherSchedule[dayKey];
                        const row = document.createElement('tr');

                        const dayCell = document.createElement('td');
                        dayCell.textContent = getFullDayName(dayKey);
                        dayCell.classList.add('day-header');
                        row.appendChild(dayCell);

                        timeHeaders.forEach(timeSlotKey => {
                            const cell = document.createElement('td');
                            const entries = dayData[timeSlotKey] || [];
                            if (entries.length > 0) {
                                const ul = document.createElement('ul');
                                ul.classList.add('schedule-entry');
                                entries.forEach(entryText => {
                                    const li = document.createElement('li');
                                    li.textContent = entryText;
                                    ul.appendChild(li);
                                    if (typeof entryText === 'string' && entryText.toUpperCase().includes("REHAT")) {
                                        cell.classList.add('rehat-cell');
                                    }
                                });
                                cell.appendChild(ul);
                            }
                            row.appendChild(cell);
                        });
                        tbody.appendChild(row);
                    }
                });

                table.appendChild(tbody);
                outputDiv.appendChild(table);
            }
        }

        function getFullDayName(dayKey) {
            const names = { "Mo": "Monday", "Tu": "Tuesday", "We": "Wednesday", "Th": "Thursday", "Fr": "Friday" };
            return names[dayKey] || dayKey;
        }

        async function processPdf() {
            const fileInput = document.getElementById('pdfFile');
            if (fileInput.files.length === 0) {
                setStatus("Please select a PDF file first.", true);
                return;
            }
            const file = fileInput.files[0];
            setStatus(`Processing PDF "${file.name}"... this may take a moment.`);

            const reader = new FileReader();
            reader.onload = async function(event) {
                try {
                    const typedarray = new Uint8Array(event.target.result);
                    const pdfDoc = await pdfjsLib.getDocument({ data: typedarray }).promise;
                    const numPages = pdfDoc.numPages;
                    let allTeachersData = {};

                    for (let i = 1; i <= numPages; i++) {
                        setStatus(`Processing page ${i} of ${numPages}...`);
                        console.log(`\n--- Processing PDF Page ${i} ---`); // Add page separator in console
                        const page = await pdfDoc.getPage(i);
                        const viewport = page.getViewport({ scale: 1.5 }); // Scale 1.5 is usually good
                        const textContent = await page.getTextContent({ normalizeWhitespace: true });
                        
                        const items = textContent.items.map(item => {
                            const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                            return {
                                text: item.str,
                                x: tx[4],
                                y: viewport.height - tx[5], // y from top
                                width: item.width * viewport.scale, // Scale width and height
                                height: item.height * viewport.scale,
                                fontName: item.fontName
                            };
                        }).sort((a,b) => a.y - b.y || a.x - b.x); // Sort all items once

                        const teacherName = extractTeacherNameJS(items, viewport.height, i); // Pass page number for logging
                        
                        if (teacherName && !allTeachersData[teacherName]) {
                            console.log(`Page ${i}: Found Teacher - ${teacherName}`);
                            const dayLabels = getDayLabelsJS(items, viewport.height);
                            const timeSlotDefinitions = getTimeSlotDefinitionsJS(items, viewport.height, i); // Pass page num for logging

                            if (dayLabels.length > 0 && timeSlotDefinitions.length > 0) {
                                allTeachersData[teacherName] = extractScheduleJS(items, dayLabels, timeSlotDefinitions, teacherName, viewport.height);
                            } else {
                                console.warn(`Page ${i} for ${teacherName}: Missing day or time labels. DayLabels: ${dayLabels.length}, TimeSlots: ${timeSlotDefinitions.length}`);
                            }
                        } else if (teacherName) {
                             console.warn(`Page ${i}: Teacher ${teacherName} might be a duplicate or already processed.`);
                        } else { 
                            // This console.warn is already in the code if teacherName is null
                            // console.warn(`No teacher name found on page ${i}`); // This is what the user is seeing
                        }
                    }

                    if (Object.keys(allTeachersData).length > 0) {
                        displaySchedules(allTeachersData);
                        setStatus(`PDF "${file.name}" processed and displayed.`);
                    } else {
                        setStatus(`Could not extract any schedule data from PDF "${file.name}". Check console for details.`, true);
                    }

                } catch (e) {
                    setStatus(`Error processing PDF: ${e.message}`, true);
                    console.error("Error processing PDF:", e);
                }
            };
            reader.onerror = function() {
                setStatus(`Error reading PDF file: ${reader.error}`, true);
            };
            reader.readAsArrayBuffer(file);
        }
        
        // --- START OF extractTeacherNameJS with DEBUG LOGS ENABLED ---
        function extractTeacherNameJS(items, pageViewportHeight, pageNumForLog = 0) { // Added pageNumForLog
            let nameParts = [];
            let collectingName = false;
            let startIndexForNameCollection = -1; 
            let keywordReferenceY = 0; 
            let keywordReferenceXMax = 0; // X-coordinate of the end of "NAMA GURU:" phrase

            const MAX_Y_FOR_KEYWORD_SEARCH = pageViewportHeight * 0.20; 
            const Y_TOLERANCE_FOR_LINE = items[0] ? items[0].height * 0.8 : 7; // Adjusted tolerance
            const X_TOLERANCE_FOR_SEQUENCE = items[0] ? items[0].width * 1.5 : 15; // Max space between keyword parts

            console.log(`--- extractTeacherNameJS - Page ${pageNumForLog} (Viewport Height: ${pageViewportHeight.toFixed(1)}) ---`);
            if (pageNumForLog) { // Only log items if we have a specific page number for debugging
                items.filter(it => it.y < MAX_Y_FOR_KEYWORD_SEARCH * 1.8).forEach(it => console.log(`  Item: "${it.text}" (y: ${it.y.toFixed(1)}, x: ${it.x.toFixed(1)}, w: ${it.width.toFixed(1)}, h: ${it.height.toFixed(1)})`));
            }


            for (let i = 0; i < items.length; i++) {
                if (items[i].y > MAX_Y_FOR_KEYWORD_SEARCH) {
                    // console.log("  Exceeded MAX_Y_FOR_KEYWORD_SEARCH, stopping keyword search.");
                    break;
                }

                const item1 = items[i];
                const text1Upper = item1.text.toUpperCase();

                if (text1Upper.includes("NAMA")) {
                    console.log(`  Found potential "NAMA" in "${item1.text}" at index ${i}, y: ${item1.y.toFixed(1)}, x: ${item1.x.toFixed(1)}`);
                    let guruFound = false;
                    let lastKeywordItemIndex = i; // Track the last item part of "NAMA GURU"

                    for (let j = i + 1; j < Math.min(i + 8, items.length); j++) {
                        const item2 = items[j];
                        // Check if item2 is on a similar line and reasonably to the right of the previous keyword part
                        if (Math.abs(item2.y - items[lastKeywordItemIndex].y) < Y_TOLERANCE_FOR_LINE &&
                            item2.x > items[lastKeywordItemIndex].x - 5 && // Allow slight overlap
                            item2.x < items[lastKeywordItemIndex].x + items[lastKeywordItemIndex].width + X_TOLERANCE_FOR_SEQUENCE) {
                            
                            const text2Upper = item2.text.toUpperCase();
                            console.log(`    Checking next item for GURU: "${item2.text}" (x: ${item2.x.toFixed(1)})`);
                            if (text2Upper.startsWith("GURU")) {
                                console.log(`    Found "GURU" part: "${item2.text}" at index ${j}`);
                                guruFound = true;
                                keywordReferenceY = item1.y; 
                                keywordReferenceXMax = item2.x + item2.width;
                                
                                if (text2Upper.includes(":")) {
                                    startIndexForNameCollection = j + 1;
                                } else {
                                    if (j + 1 < items.length && items[j+1].text.trim() === ":" && 
                                        Math.abs(items[j+1].y - keywordReferenceY) < Y_TOLERANCE_FOR_LINE &&
                                        items[j+1].x > item2.x - 5 && items[j+1].x < item2.x + item2.width + X_TOLERANCE_FOR_SEQUENCE) {
                                        console.log(`      Found colon ":" after GURU.`);
                                        startIndexForNameCollection = j + 2;
                                        keywordReferenceXMax = items[j+1].x + items[j+1].width;
                                    } else {
                                        startIndexForNameCollection = j + 1;
                                    }
                                }
                                break; 
                            }
                            lastKeywordItemIndex = j; // Update if it's a connecting word like "BIN" (though unlikely here)
                        } else if (item2.y > items[lastKeywordItemIndex].y + Y_TOLERANCE_FOR_LINE * 1.5) { // Clearly on a new line
                            console.log(`    Next item "${item2.text}" is on a new line, stopping GURU search for this "NAMA".`);
                            break;
                        }
                    }

                    if (guruFound) {
                        collectingName = true;
                        console.log(`  "NAMA GURU" confirmed. RefY: ${keywordReferenceY.toFixed(1)}, RefXMax: ${keywordReferenceXMax.toFixed(1)}. Start name collection from index: ${startIndexForNameCollection}`);
                        
                        // Try to grab initial name parts ON THE SAME LINE as "NAMA GURU:"
                        for(let k = startIndexForNameCollection; k < items.length; k++){
                            const currentItem = items[k];
                            if(Math.abs(currentItem.y - keywordReferenceY) < Y_TOLERANCE_FOR_LINE && currentItem.x > keywordReferenceXMax - 5) {
                                const currentPartUpper = currentItem.text.toUpperCase().trim();
                                if (currentPartUpper.startsWith("SMK") || currentPartUpper.includes("SESI PAGI") ||
                                    currentPartUpper.includes("REHAT") || currentPartUpper.includes("ASSEMBLY") ||
                                    currentItem.text.match(/\d{1,2}:\d{2}/) || currentPartUpper.includes("JADUAL WAKTU")) {
                                    startIndexForNameCollection = k; // Update where to start for next line if needed
                                    break;
                                }
                                if (currentItem.text.trim() && !currentItem.text.match(/^\W+$/)) {
                                     nameParts.push(currentItem.text.trim());
                                     console.log(`    Added initial part from keyword line: "${currentItem.text.trim()}"`);
                                     keywordReferenceXMax = currentItem.x + currentItem.width; // Update X for next part on same line
                                     startIndexForNameCollection = k + 1; 
                                }
                            } else {
                                startIndexForNameCollection = k; // This item is not part of the initial same-line name
                                break;
                            }
                        }
                        break; 
                    }
                } else if (text1Upper.startsWith("TEACHER")) { 
                    collectingName = true;
                    keywordReferenceY = item1.y;
                    keywordReferenceXMax = item1.x + item1.width;
                    let teacherText = item1.text;
                    let namePartAfterTeacher = teacherText.substring("TEACHER".length).replace(/^[:\s]+/, "").trim();
                    if (namePartAfterTeacher) nameParts.push(namePartAfterTeacher);
                    startIndexForNameCollection = i + 1;
                    console.log(`  "TEACHER" found. Initial parts: [${nameParts.join(', ')}]. RefY: ${keywordReferenceY.toFixed(1)}. Start name collection from index: ${startIndexForNameCollection}`);
                    break;
                }
            }

            if (collectingName && startIndexForNameCollection !== -1) {
                console.log(`  Starting Phase 2 name collection. Initial parts: [${nameParts.join(' ')}]. Start index: ${startIndexForNameCollection}`);
                let lastCollectedY = keywordReferenceY; 
                let lastCollectedX = keywordReferenceXMax;

                for (let i = startIndexForNameCollection; i < items.length; i++) {
                    const item = items[i];
                    const upperText = item.text.toUpperCase().trim();

                    if (nameParts.length > 0 && item.y > lastCollectedY + Y_TOLERANCE_FOR_LINE * 2.5) { 
                        console.log(`    Stopping name collection (Phase 2): Y jump too large. Item: "${item.text}", y: ${item.y.toFixed(1)}, lastY: ${lastCollectedY.toFixed(1)}`);
                        break;
                    }
                    if (item.y > keywordReferenceY + pageViewportHeight * 0.08 && nameParts.length > 0) { 
                        console.log(`    Stopping name collection (Phase 2): Too far below keyword line. Item: "${item.text}", y: ${item.y.toFixed(1)}`);
                        break;
                    }
                     if (upperText.startsWith("SMK") || upperText.includes("SESI PAGI") ||
                        upperText.includes("REHAT") || upperText.includes("ASSEMBLY") ||
                        upperText.includes("JADUAL WAKTU") || item.text.match(/\d{1,2}:\d{2}/)) {
                        console.log(`    Stopping name collection (Phase 2): Found stop keyword "${upperText}"`);
                        break;
                    }
                    if (nameParts.length >= 8) { 
                        console.log("    Stopping name collection (Phase 2): Max name parts reached.");
                        break;
                    }

                    if (item.text && item.text.trim().length > 0 && !item.text.match(/^\W+$/)) {
                        // Check if item is on the same line as last collected or a new line closely below
                        if ( (Math.abs(item.y - lastCollectedY) < Y_TOLERANCE_FOR_LINE && item.x > lastCollectedX - 10) || // Same line, to the right
                             (item.y > lastCollectedY && item.y < lastCollectedY + Y_TOLERANCE_FOR_LINE * 2) // New line, closely below
                           ) {
                            if (upperText !== "NAMA" && upperText !== "GURU" && upperText !== "GURU:" && item.text.trim() !== ":") {
                                nameParts.push(item.text.trim());
                                lastCollectedY = item.y;
                                lastCollectedX = item.x + item.width;
                                console.log(`      Collected (Phase 2): "${item.text.trim()}", Parts now: [${nameParts.join(' ')}]`);
                            }
                        }
                    }
                }
            }

            if (nameParts.length === 0) {
                console.log("  No name parts collected in total.");
                return null;
            }

            let fullName = nameParts.join(" ").replace(/[:,-]/g, "").trim().toUpperCase();
            console.log("  Raw full name before final cleaning:", fullName);

            const noiseParts = [ 
                "NAMA GURU", "GURU", "TEACHER",
                "SMK SERI PULAI PERDANA", "JOHOR BAHRU", "SERI PULAI PERDANA", "PULAI PERDANA",
                "JADUAL WAKTU SESI PAGI BIL 1 2025", "JADUAL WAKTU SESI PAGI", "SESI PAGI BIL 1 2025",
                "SESI PAGI BIL.", "BIL 1 2025", "1 2025", "2025", "SMK",
                "MORNING ASSEMBLY", "REHAT"
            ];

            let cleanedName = fullName;
            noiseParts.forEach(part => {
                const regexPart = part.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').split(/\s+/).join('\\s*');
                const regex = new RegExp(regexPart, "gi");
                cleanedName = cleanedName.replace(regex, "").trim();
            });
            
            cleanedName = cleanedName.replace(/^[:\s]+|[:\s]+$/g, ""); 

            console.log("  Final cleaned name for Page " + pageNumForLog + ":", `"${cleanedName}"`);
            return cleanedName && cleanedName.length > 3 ? cleanedName : null; 
        }
        // --- END OF extractTeacherNameJS with DEBUG LOGS ENABLED ---


        // ... (The rest of your JS functions: getDayLabelsJS, getTimeSlotDefinitionsJS, extractScheduleJS, etc. should be here)
        // ... (Ensure they are identical to the previous "good" version or the one you were working with)
        function getDayLabelsJS(items, pageHeight) {
            const dayLabels = [];
            const pdfDays = ["Mo", "Tu", "We", "Th", "Fr"];
            const MIN_Y_FOR_DAY = pageHeight * 0.20; 
            const MAX_Y_FOR_DAY = pageHeight * 0.90; 

            for (const item of items) {
                if (pdfDays.includes(item.text) && item.x < pageHeight * 0.1) { 
                    if(item.y > MIN_Y_FOR_DAY && item.y < MAX_Y_FOR_DAY) { 
                        let existing = dayLabels.find(d => d.day === item.text);
                        if (!existing) {
                             dayLabels.push({ day: item.text, y_center: item.y + item.height / 2, y0: item.y, y1: item.y + item.height });
                        } else { 
                            existing.y0 = Math.min(existing.y0, item.y);
                            existing.y1 = Math.max(existing.y1, item.y + item.height);
                            existing.y_center = (existing.y0 + existing.y1) / 2;
                        }
                    }
                }
            }
            return dayLabels.sort((a,b) => a.y_center - b.y_center);
        }

        function getTimeSlotDefinitionsJS(items, pageHeight, pageNumForLog = 0) { // Added pageNumForLog for context
            const timeSlotDefs = [];
            const MIN_Y_FOR_TIME_HEADER = pageHeight * 0.12; // Adjusted slightly higher
            const MAX_Y_FOR_TIME_HEADER = pageHeight * 0.22; // Adjusted slightly lower for tighter focus
            
            // console.log(`--- getTimeSlotDefinitionsJS - Page ${pageNumForLog} ---`);
            const headerItems = items.filter(it => 
                it.y > MIN_Y_FOR_TIME_HEADER && it.y < MAX_Y_FOR_TIME_HEADER && 
                it.text.match(/^\d{1,2}:\d{2}$/)
            ); 
            // headerItems.forEach(hi => console.log(`  Header time item: "${hi.text}" x:${hi.x.toFixed(1)} y:${hi.y.toFixed(1)}`));


            const timeXPositions = {}; 
            headerItems.forEach(item => {
                let timeStr = item.text.split(':').map(p => p.padStart(2, '0')).join(':'); 
                if (timeStr.match(/^\d:\d{2}$/)) timeStr = "0" + timeStr;

                if (!timeXPositions[timeStr]) timeXPositions[timeStr] = [];
                // Store multiple occurrences if a time appears more than once (e.g., 09:45)
                timeXPositions[timeStr].push({ text: item.text, x: item.x, width: item.width, center: item.x + item.width / 2 });
            });

            for (const time in timeXPositions) {
                timeXPositions[time].sort((a,b) => a.x - b.x); // Sort by x-position
            }
            // console.log("  Time X Positions:", timeXPositions);
            
            EXPECTED_TIME_SLOTS_KEYS.forEach(slotKey => {
                const [startStrFull, endStrFull] = slotKey.split('-');
                
                const startHeaderInstances = timeXPositions[startStrFull];
                
                if (startHeaderInstances && startHeaderInstances.length > 0) {
                    let chosenStartPosition = startHeaderInstances[0]; // Default to the first (leftmost) instance

                    // Specific logic for the ambiguous "09:45" start time
                    if (startStrFull === "09:45" && startHeaderInstances.length > 1) {
                        if (slotKey === "09:45-10:00") { 
                           // This slot usually corresponds to the "09:45" that is NOT part of the wide REHAT block.
                           // It's often the second "09:45" text instance if the REHAT block also starts at 09:45.
                           // We need a way to distinguish. One heuristic: find the 09:45 that aligns well with a 10:00.
                           const tenOClockInstances = timeXPositions["10:00"];
                           if (tenOClockInstances && tenOClockInstances.length > 0) {
                               let bestMatch = null;
                               let smallestGap = Infinity;
                               for (const sp of startHeaderInstances) {
                                   for (const tenO of tenOClockInstances) {
                                       // Check if 'sp' could be the start of a column ending at 'tenO'
                                       if (sp.x < tenO.x && Math.abs(sp.x + sp.width - tenO.x) < 30 ) { // Reasonable gap
                                           if (Math.abs(sp.x + sp.width - tenO.x) < smallestGap) {
                                               smallestGap = Math.abs(sp.x + sp.width - tenO.x);
                                               bestMatch = sp;
                                           }
                                       }
                                   }
                               }
                               if (bestMatch) chosenStartPosition = bestMatch;
                               else chosenStartPosition = startHeaderInstances[startHeaderInstances.length-1]; // Fallback: rightmost "09:45"
                           } else {
                               chosenStartPosition = startHeaderInstances[startHeaderInstances.length-1]; // Fallback if 10:00 not found
                           }
                        } // For "09:45-10:15", the default leftmost chosenStartPosition is usually correct for the REHAT block.
                    }


                    let slotX0 = chosenStartPosition.x - 3; // Small padding to the left
                    let slotX1;

                    // Determine x1 based on the slotKey and available end time positions
                    const endHeaderInstances = timeXPositions[endStrFull];

                    if (slotKey === "09:45-10:15" && timeXPositions["10:15"] && timeXPositions["10:15"].length > 0) { 
                        slotX1 = timeXPositions["10:15"][0].x + timeXPositions["10:15"][0].width + 3;
                    } else if (slotKey === "10:30-11:00" && timeXPositions["10:30"] && timeXPositions["11:00"] && timeXPositions["10:30"].length > 0 && timeXPositions["11:00"].length > 0) { 
                        slotX0 = timeXPositions["10:30"][0].x - 3; 
                        slotX1 = timeXPositions["11:00"][0].x + timeXPositions["11:00"][0].width + 3;
                    } else if (endHeaderInstances && endHeaderInstances.length > 0) {
                        // Find an instance of endStrFull that is to the right of chosenStartPosition
                        const suitableEndPos = endHeaderInstances.find(ep => ep.x > chosenStartPosition.x + chosenStartPosition.width - 10); // allow slight overlap
                        if (suitableEndPos) {
                           const startH = parseInt(startStrFull.split(':')[0]);
                           const startM = parseInt(startStrFull.split(':')[1]);
                           const endH = parseInt(endStrFull.split(':')[0]);
                           const endM = parseInt(endStrFull.split(':')[1]);
                           const durationMinutes = (endH - startH) * 60 + (endM - startM);

                           if (durationMinutes === 15) { // For 15-minute slots, x1 is the start of the end time text
                               slotX1 = suitableEndPos.x + 3; 
                           } else { // For longer slots, x1 is the end of the end time text
                               slotX1 = suitableEndPos.x + suitableEndPos.width + 3;
                           }
                        } else { // If no suitable end position found for the end time string
                             slotX1 = chosenStartPosition.x + chosenStartPosition.width + 35; // Fallback: approx width
                        }
                    } else { // Fallback if end time string itself is not found in header positions
                        slotX1 = chosenStartPosition.x + chosenStartPosition.width + 35; 
                    }

                    if (slotX1 > slotX0 + 5) { // Ensure a minimum width for the slot
                        timeSlotDefs.push({ time_slot_key: slotKey, x0: slotX0, x1: slotX1 });
                        // console.log(`    Defined slot: ${slotKey} -> x0: ${slotX0.toFixed(1)}, x1: ${slotX1.toFixed(1)}`);
                    } else {
                        // console.warn(`    Skipped slot ${slotKey} for Page ${pageNumForLog}: Invalid x-coordinates (x0: ${slotX0.toFixed(1)}, x1: ${slotX1.toFixed(1)})`);
                    }
                } else {
                    // console.warn(`    Could not find start time "${startStrFull}" in header for slot ${slotKey} on Page ${pageNumForLog}`);
                }
            });
            
            const finalDefs = [];
            const addedKeys = new Set();
            // Ensure slots are added in the EXPECTED_TIME_SLOTS_KEYS order
            EXPECTED_TIME_SLOTS_KEYS.forEach(expectedKey => {
                const foundDef = timeSlotDefs.find(def => def.time_slot_key === expectedKey);
                if (foundDef && !addedKeys.has(expectedKey)) {
                    finalDefs.push(foundDef);
                    addedKeys.add(expectedKey);
                }
            });
            // This second loop should ideally not add anything if all expected keys were found and processed.
            // timeSlotDefs.forEach(def => { 
            //     if(!addedKeys.has(def.time_slot_key)){
            //         finalDefs.push(def); // Should be rare if EXPECTED_TIME_SLOTS_KEYS is comprehensive
            //     }
            // });

            return finalDefs;
        }

        function extractScheduleJS(items, dayLabels, timeSlotDefinitions, teacherNameFull, pageHeight) {
            const schedule = {};
            DAYS_ORDER.forEach(dKey => {
                schedule[dKey] = {};
                EXPECTED_TIME_SLOTS_KEYS.forEach(tsKey => schedule[dKey][tsKey] = []);
            });

            const teacherNameTokensArray = teacherNameFull.toUpperCase().split(/\s+/)
                .map(p => p.replace(/[^A-Z0-9À-ÖØ-öø-ſ]/gi, '')) 
                .filter(p => p.length > 1 && !["BIN", "BINTI", "A/L", "A/P", "BT", "BTE", "B", "EN", "PN"].includes(p)); // Filtered more common title/connectors
            const teacherNameTokens = new Set(teacherNameTokensArray);
            
            const commonSubjectCodes = ["PH", "KOKO", "P", "SJ", "MM", "BI", "SN", "BM", "RBT", "ASK", "PM", "PI", "PS", "PA", "PJ", "GE", "FIZ", "KIM", "BIO", "MMT", "MT", "SEJ", "REHAT", "TAW", "IV", "BC"];
            const commonTitlesForCellFilter = ["EN.", "PN.", "CIK.", "UST.", "DR.", "MR."];


            const itemsByCell = {}; 
            const MIN_Y_FOR_CONTENT = pageHeight * 0.22; 
            const MAX_Y_FOR_CONTENT = pageHeight * 0.90; 

            for (const item of items) {
                if (item.y < MIN_Y_FOR_CONTENT || item.y > MAX_Y_FOR_CONTENT) continue;
                
                const itemTextOriginal = item.text.trim();
                const itemTextUpper = itemTextOriginal.toUpperCase();
                let skipItem = false;

                // Filter out parts of the teacher's name appearing in the cell
                // This is tricky because names can be fragmented.
                const cleanedItemForNameCheck = itemTextUpper.replace(/[^A-Z0-9À-ÖØ-öø-ſ]/gi, '');
                if (teacherNameTokens.has(cleanedItemForNameCheck) && !commonSubjectCodes.includes(itemTextUpper) && cleanedItemForNameCheck.length > 1) {
                    skipItem = true;
                }
                // Also filter common titles if they are likely part of the teacher name in the cell
                if (commonTitlesForCellFilter.includes(itemTextUpper) && itemTextUpper.length <= 4) { // e.g. "EN."
                    // This might be too aggressive if a title is also a subject code.
                    // A more robust check would see if a *known name token* is *also* present in the same cell.
                    // For now, let's be a bit conservative: if it's ONLY a title, it might be part of name.
                    skipItem = true; 
                }


                if (skipItem) continue;

                for (const dayLabel of dayLabels) {
                    const itemYCenter = item.y + item.height / 2;
                    if (itemYCenter >= dayLabel.y0 - 2 && itemYCenter <= dayLabel.y1 + dayLabel.height * 0.5 + 2) { // Looser y-check for day bands
                        for (const slotDef of timeSlotDefinitions) {
                            const itemXCenter = item.x + item.width / 2;
                            if (itemXCenter >= slotDef.x0 && itemXCenter <= slotDef.x1) {
                                const cellKey = `${dayLabel.day}_${slotDef.time_slot_key}`;
                                if (!itemsByCell[cellKey]) itemsByCell[cellKey] = [];
                                if (itemTextOriginal && !itemTextOriginal.match(/^\d{1,2}:\d{2}$/)) { 
                                   itemsByCell[cellKey].push({text: itemTextOriginal, x: item.x, y: item.y, height: item.height});
                                }
                                break; 
                            }
                        }
                    }
                }
            }

            for(const cellKey in itemsByCell){
                const [day, slot] = cellKey.split('_');
                const cellItems = itemsByCell[cellKey];
                if (cellItems.length === 0) continue;

                const lines = {};
                cellItems.sort((a,b) => a.y - b.y || a.x - b.x); 

                cellItems.forEach(itm => {
                    let foundLineKey = null;
                    // Group items on the same visual line more carefully
                    const currentLineY = parseFloat(itm.y.toFixed(0)); // Group by integer y pixel
                    for (const lineYStr in lines) {
                         // Check if y is within half of item's height from an existing line's anchor y
                        if (Math.abs(itm.y - parseFloat(lineYStr)) < itm.height * 0.6) { 
                            foundLineKey = lineYStr;
                            break;
                        }
                    }
                    if (foundLineKey) {
                        lines[foundLineKey].push(itm);
                    } else {
                        lines[itm.y.toFixed(0)] = [itm]; // Use integer y as line key
                    }
                });

                let fullCellTextEntries = [];
                Object.keys(lines).sort((a,b) => parseFloat(a) - parseFloat(b)).forEach(lineYStr => {
                    const lineText = lines[lineYStr].sort((a,b) => a.x - b.x).map(itm => itm.text).join(" ");
                    if (lineText.trim()) {
                        fullCellTextEntries.push(lineText.trim());
                    }
                });
                
                if(fullCellTextEntries.length > 0) {
                     schedule[day][slot] = fullCellTextEntries;
                }
            }
            return schedule;
        }


        window.addEventListener('DOMContentLoaded', () => {
            loadAndDisplayJson(DEFAULT_JSON_PATH, `default schedule (${DEFAULT_JSON_PATH})`);
        });

    </script>
</body>
</html>